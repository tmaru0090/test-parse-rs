 {
            if *is_system {
                match name.as_str() {
                    "play_music" => {
                        if args.len() != 1 {
                            return Err("play_music expects exactly one argument".into());
                        }
                        let file_path = match self.execute_node(&args[0])? {
                            Value::String(v) => v,
                            _ => {
                                return Err("show_msg_box expects a string as the file name".into())
                            }
                        };
                        // 出力ストリームを作成
                        let (_stream, stream_handle) = OutputStream::try_default().unwrap();
                        // 音楽ファイルを読み込む
                        let file = File::open(file_path).unwrap();
                        let source = rodio::Decoder::new(BufReader::new(file)).unwrap();
                        // 音楽の長さを取得
                        let duration = source.total_duration().unwrap();

                        // 音楽を再生
                        stream_handle.play_raw(source.convert_samples()).unwrap();

                        // 音楽が再生される間、プログラムを終了させない
                        std::thread::sleep(duration);
                        return Ok(Value::Null);
                    }
                    "str" => {
                        if args.len() != 1 {
                            return Err("to_str expects exactly one argument".into());
                        }
                        let n = match self.execute_node(&args[0])? {
                            Value::Number(v) => v,
                            _ => return Err("to_str expects a string as the file name".into()),
                        };
                        let string = n.to_string();
                        return Ok(serde_json::json!(string));
                    }
                    "show_msg_box" => {
                        if args.len() != 4 {
                            return Err("show_msg_box expects exactly two arguments".into());
                        }
                        let message_type = match self.execute_node(&args[0])? {
                            Value::String(v) => v,
                            _ => {
                                return Err("show_msg_box expects a string as the file name".into())
                            }
                        };
                        let title = match self.execute_node(&args[1])? {
                            Value::String(v) => v,
                            _ => {
                                return Err("show_msg_box expects a string as the file name".into())
                            }
                        };
                        let message = match self.execute_node(&args[2])? {
                            Value::String(v) => v,
                            _ => {
                                return Err("show_msg_box expects a string as the file name".into())
                            }
                        };
                        let icon = match self.execute_node(&args[3])? {
                            Value::String(v) => Some(v),
                            _ => None,
                        };
                        let responce =
                            show_messagebox(&message_type, &title, &message, icon.as_deref());
                        return Ok(serde_json::json!(responce));
                    }
                    "write_at_file" => {
                        if args.len() != 3 {
                            return Err("write_file expects exactly two arguments".into());
                        }
                        let file_name = match self.execute_node(&args[0])? {
                            Value::String(v) => v,
                            _ => return Err("write_file expects a string as the file name".into()),
                        };
                        let insert_str = match self.execute_node(&args[1])? {
                            Value::String(v) => v,
                            Value::Array(arr) => arr
                                .into_iter()
                                .map(|v| {
                                    if let Value::String(s) = v {
                                        Ok::<String, String>(s)
                                    } else {
                                        Err("write_file expects an array of strings as the content"
                                            .into())
                                    }
                                })
                                .collect::<Result<Vec<String>, String>>()?
                                .join("\n"),
                            _ => return Err(
                                "write_file expects a string or an array of strings as the content"
                                    .into(),
                            ),
                        };
                        let pos = match self.execute_node(&args[2])? {
                            Value::Number(v) => v.as_u64().unwrap(),
                            _ => 0,
                        };
                        // ファイルを開く
                        let mut file = OpenOptions::new()
                            .read(true)
                            .write(true)
                            .open(&file_name)
                            .unwrap();

                        // 既存の内容をすべて読み込む
                        let mut content = String::new();
                        file.read_to_string(&mut content).unwrap();
                        /*
                                                // 挿入する位置までのバイト数を計算
                                                let split_index = pos as usize;

                                                // 挿入位置に文字列を挿入
                                                let (head, tail) = content.split_at(split_index);
                        */

                        // posバイト目ではなく、pos文字目で分割する
                        let char_pos = content
                            .char_indices()
                            .nth(pos as usize)
                            .map(|(i, _)| i)
                            .unwrap_or(content.len());

                        // 挿入位置に文字列を挿入
                        let (head, tail) = content.split_at(char_pos);

                        let new_content = format!("{}{}{}", head, insert_str, tail);

                        // ファイルの内容を書き換えるためにシークしてから書き込み
                        file.seek(SeekFrom::Start(0)).unwrap();
                        file.write_all(new_content.as_bytes()).unwrap();

                        return Ok(Value::Null);
                    }
                    "open_recent" => {
                        if !args.is_empty() {
                            return Err("open_recent expects no arguments".into());
                        }

                        // 最近使用したアイテムフォルダのパス
                        let recent_folder =
                            std::env::var("APPDATA").unwrap() + r"\Microsoft\Windows\Recent";

                        // フォルダ内のファイルを取得
                        let paths = std::fs::read_dir(recent_folder)
                            .unwrap()
                            .filter_map(Result::ok)
                            .map(|entry| entry.path())
                            .collect::<Vec<std::path::PathBuf>>();
                        let recent_lists = serde_json::json!(paths);

                        return Ok(recent_lists.clone());
                    }

                    "sleep" => {
                        if args.len() != 1 {
                            return Err("sleep expects exactly one argument".into());
                        }
                        let duration = match self.execute_node(&args[0])? {
                            Value::Number(v) => v,
                            _ => return Err("read_file expects a string as the file name".into()),
                        };
                        sleep(std::time::Duration::from_secs(duration.as_u64().unwrap()));
                        return Ok(Value::Null);
                    }

                    "read_file" => {
                        if args.len() != 1 {
                            return Err("read_file expects exactly one argument".into());
                        }
                        let file_name = match self.execute_node(&args[0])? {
                            Value::String(v) => v,
                            _ => return Err("read_file expects a string as the file name".into()),
                        };
                        let mut file = File::open(file_name).unwrap();
                        let mut contents = String::new();
                        file.read_to_string(&mut contents).unwrap();
                        return Ok(Value::String(contents));
                    }

                    "write_file" => {
                        if args.len() != 2 {
                            return Err("write_file expects exactly two arguments".into());
                        }
                        let file_name = match self.execute_node(&args[0])? {
                            Value::String(v) => v,
                            _ => return Err("write_file expects a string as the file name".into()),
                        };
                        let content = match self.execute_node(&args[1])? {
                            Value::String(v) => v,
                            Value::Array(arr) => arr
                                .into_iter()
                                .map(|v| {
                                    if let Value::String(s) = v {
                                        Ok::<String, String>(s)
                                    } else {
                                        Err("write_file expects an array of strings as the content"
                                            .into())
                                    }
                                })
                                .collect::<Result<Vec<String>, String>>()?
                                .join("\n"),
                            _ => return Err(
                                "write_file expects a string or an array of strings as the content"
                                    .into(),
                            ),
                        };
                        let mut file = File::create(file_name).unwrap();
                        file.write_all(content.as_bytes()).unwrap();

                        return Ok(Value::Null);
                    }

                    "print" => {
                        let format = match self.execute_node(&args[0])? {
                            Value::String(v) => v,
                            _ => return Err("print expects a string as the format".into()),
                        };
                        let args = self.execute_node(&args[1])?;

                        match args {
                            Value::Array(arr) => {
                                let mut formatted_args: Vec<String> = arr
                                    .iter()
                                    .map(|arg| match arg {
                                        Value::String(s) => s.clone(),
                                        Value::Number(n) => n.to_string(),
                                        Value::Bool(b) => b.to_string(),
                                        _ => format!("{:?}", arg),
                                    })
                                    .collect();

                                let mut formatted_string = format.clone();
                                for arg in arr {
                                    if formatted_string.contains("{:?}") {
                                        formatted_string = formatted_string.replacen(
                                            "{:?}",
                                            &format!("{:?}", arg),
                                            1,
                                        );
                                    } else {
                                        formatted_string = formatted_string.replacen(
                                            "{}",
                                            &formatted_args.remove(0),
                                            1,
                                        );
                                    }
                                }
                                println!("{}", formatted_string);
                            }
                            _ => return Err("print expects an array of arguments".into()),
                        }
                        return Ok(Value::Null);
                    }

                    "println" => {
                        for arg in args {
                            let value = self.execute_node(arg)?;
                            print!("{}", value);
                        }
                        println!();
                        return Ok(Value::Null);
                    }
                    "exit" => {
                        if args.len() != 1 {
                            return Err("exit expects exactly one argument".into());
                        }
                        let status = match self.execute_node(&args[0])? {
                            Value::Number(n) => {
                                n.as_i64().ok_or("exit expects a positive integer")?
                            }
                            _ => return Err("exit expects a number as the status".into()),
                        };
                        std::process::exit(status.try_into().unwrap());

                        return Ok(Value::Null);
                    }
                    "args" => {
                        if !args.is_empty() {
                            return Err("args expects no arguments".into());
                        }
                        let args: Vec<String> = std::env::args().collect();
                        let value: Value =
                            Value::Array(args.into_iter().map(Value::String).collect());
                        return Ok(value);
                    }
                    "cmd" => {
                        if evaluated_args.len() < 1 {
                            return Err("cmd expects at least one argument".into());
                        }
                        let command = match &evaluated_args[0] {
                            Value::String(v) => v.clone(),
                            _ => return Err("cmd expects the first argument to be a string".into()),
                        };
                        let command_args =
                            if evaluated_args.len() > 1 {
                                match &evaluated_args[1] {
                                    Value::Array(v) => v
                                        .iter()
                                        .filter_map(|item| {
                                            if let Value::String(s) = item {
                                                Some(s.clone())
                                            } else {
                                                None
                                            }
                                        })
                                        .collect(),
                                    _ => return Err(
                                        "cmd expects the second argument to be an array of strings"
                                            .into(),
                                    ),
                                }
                            } else {
                                Vec::new()
                            };
                        let output = Command::new(command)
                            .args(&command_args)
                            .output()
                            .expect("外部コマンドの実行に失敗しました");
                        let stdout = String::from_utf8_lossy(&output.stdout).to_string();
                        let stderr = String::from_utf8_lossy(&output.stderr).to_string();
                        return Ok(Value::Array(vec![
                            Value::String(stdout),
                            Value::String(stderr),
                        ]));
                    }
                    // 他のシステム関数の処理...
                    _ => return Err(format!("Unknown function: {}", name)),
                }
            }
        }
