
use anyhow::Result as R;
use property_rs::Property;
#[derive(PartialEq,Debug,Clone)]
enum TokenType {
    /*記号*/
    Add,   // +
    Sub,   // -
    Mul,   // x
    Div,   // ÷  
    LeftParen, // (
    RightParen, // ) 
    Conma, // ,
    Equals, // =
    AtSign, // @ 
    Semi,   // ;
    /*識別子*/
    Ident, 
    /*その他*/ 
    Eof, // トークンの終わり
}

#[derive(PartialEq,Debug,Clone)]
enum NodeType{
    /*記号*/
    Add,   // +
    Sub,   // -
    Mul,   // x
    Div,   // ÷  
    LeftParen, // (
    RightParen, // ) 
    Conma, // ,
    Equals, // =
    AtSign, // @ 
    Semi,   // ;
    
    /*変数*/
    VarInt(i32),
    VarString(String),
}
#[derive(Debug,Property,Clone)]
struct Token {
    #[property(get)]
    token_value: String,
    #[property(get)]
    token_type: TokenType,
}

impl Token {
    fn new(token_value: String, token_type: TokenType) -> Self {
        Token { token_value, token_type }
    }
}

struct Tokenizer {
    input: String,
}

impl Tokenizer {
    fn new(input: String) -> Self {
        Tokenizer { input }
    }

    fn is_symbol(&self, c: char) -> bool {
        match c {
            '+' | '-' | '*' | '/' | '(' | ')' | ',' | '=' | ';' | '@'  => true,
            _ => false,
        }
    }
    fn tokenize(&mut self) -> R<Vec<Token>> {
        let mut tokens: Vec<Token> = Vec::new();
        let input = self.input.clone();
        let mut i = 0;

        while i < input.len() {
            let c = input.chars().nth(i).expect("index out of bounds.");

            if c == ' ' || c == '\n' || c == '\t' {
                i += 1;
                continue;
            }

            if c.is_alphanumeric() || c == '_' {
                let mut ident = String::new();
                while i < input.len() {
                    let c = input.chars().nth(i).expect("index out of bounds.");
                    if c.is_alphanumeric() || c == '_' {
                        ident.push(c);
                        i += 1;
                    } else {
                        break;
                    }
                }
                tokens.push(Token::new(ident, TokenType::Ident));
            } else if self.is_symbol(c) {
                let token_type = match c {
                    '+' => TokenType::Add,
                    '-' => TokenType::Sub,
                    '*' => TokenType::Mul,
                    '/' => TokenType::Div,
                    '(' => TokenType::LeftParen,
                    ')' => TokenType::RightParen,
                    ',' => TokenType::Conma,
                    '=' => TokenType::Equals,
                    '@' => TokenType::AtSign,
                    ';' => TokenType::Semi,
                    _ => panic!("Unexpected symbol: {:?}", c),
                };
                tokens.push(Token::new(c.to_string(), token_type));
                i += 1;
            } else {
                panic!("Failed to tokenize: {:?}", c);
            }
            // 終了トークンの生成
            tokens.push(Token::new(String::from(""),TokenType::Eof));
        }

        Ok(tokens)
    }
}
struct Node{
    node_value: NodeType,
    node_next: Option<Box<Node>>,
}
impl Node{
    fn new(node_value:NodeType,node_next:Option<Box<Node>>)->Self{
        Node{
            node_value,
            node_next,
        }
    }
}
struct Parser<'a>{
    tokens:&'a Vec<Token>,
    i:usize,
}
impl<'a> Parser<'a>{
    fn new(tokens:&'a Vec<Token>)->Self{Parser{tokens,i:0}}
    fn term(&mut self)->R<Box<Node>>{
            }
    fn factor(&mut self)->R<Box<Node>>{
          
    }
    fn expr(&mut self)->R<Box<Node>>{
           }
    fn current_tokens(&self)->Token{
        self.tokens[self.i].clone()
    }
    fn next_tokens(&self){
        self.i+=1;
    }
    fn program(&mut self)->R<Vec<Node>>{
        let mut nodes:Vec<Node> = Vec::new();
        let tokens = self.tokens;
        while self.current_tokens().token_type != TokenType::Eof{
            
        }
        Ok(nodes)
    }
}

fn main() -> R<()> {
    let mut tokenizer = Tokenizer::new(String::from("@test =100;"));
    let tokens = tokenizer.tokenize()?;
    println!("{:?}", tokens);
    let mut parser = Parser::new(&tokens);
    let nodes = parser.program();
    Ok(())
}
